<!doctype html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Virtual Swarmalator</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }

    /* ===== Theme variables ===== */
    :root{
      --bg: #f0f0ef;
      --grain-opacity: 0.035;

      --panel-bg: rgba(255,255,255,0.55);
      --panel-border: rgba(255,255,255,0.75);
      --panel-text: rgba(0,0,0,0.80);
      --panel-text-strong: rgba(0,0,0,0.92);
      --panel-text-mute: rgba(0,0,0,0.55);

      --accent: #1a6fb5;

      /* canvas colors (as rgb triples) */
      --particle-color: 60, 60, 60;
      --mag-off: 165,163,158;
      --mag-on: 30,100,255;
    }

    [data-theme="dark"]{
      --bg: #0a0a0a;
      --grain-opacity: 0.035;

      --panel-bg: rgba(18,18,18,0.55);
      --panel-border: rgba(255,255,255,0.10);
      --panel-text: rgba(255,255,255,0.82);
      --panel-text-strong: rgba(255,255,255,0.92);
      --panel-text-mute: rgba(255,255,255,0.55);

      --accent: #66b6ff;

      --particle-color: 160, 160, 160;
      --mag-off: 55,55,60;
      --mag-on: 80,200,255;
    }

    html, body {
      margin: 0; padding: 0;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
      transition: background 0.35s ease;
    }

    /* Grain overlay */
    body::before{
      content:'';
      position:fixed; inset:0;
      pointer-events:none;
      opacity: var(--grain-opacity);
      z-index:2;
      background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      background-size:180px 180px;
    }

    /* Fullscreen canvas */
    #particle-canvas{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      z-index:1;
      display:block;
    }

    /* ===== Theme toggle ===== */
    .theme-toggle{
      position: fixed;
      top: 16px; right: 16px;
      z-index: 4;
      display:flex;
      align-items:center;
      gap: 8px;
      background: none;
      border: none;
      padding: 0;
      cursor: pointer;
      user-select:none;
    }
    .toggle-icon{
      font-size: 0.95rem;
      color: var(--panel-text-mute);
    }
    .toggle-track{
      width: 40px; height: 22px;
      background: rgba(127,127,127,0.35);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 11px;
      position: relative;
      backdrop-filter: blur(10px);
    }
    .toggle-knob{
      position:absolute;
      top: 3px; left: 3px;
      width: 16px; height: 16px;
      border-radius: 50%;
      background: rgba(255,255,255,0.85);
      transition: transform 0.25s ease, background 0.25s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.25);
    }
    [data-theme="dark"] .toggle-knob{
      transform: translateX(18px);
      background: rgba(10,10,10,0.9);
    }

    /* Left control panel */
    .panel{
      position:fixed;
      left:16px; top:16px;
      z-index:3;
      width:260px;
      padding:14px 14px 12px;
      border-radius:12px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      backdrop-filter: blur(14px) saturate(1.2);
      -webkit-backdrop-filter: blur(14px) saturate(1.2);
      color: var(--panel-text);
      font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      user-select:none;
      transition: background 0.35s ease, border-color 0.35s ease, color 0.35s ease;
    }
    .panel h3{
      margin:0 0 10px 0;
      font-size:13px;
      font-weight:600;
      letter-spacing:0.2px;
      color: var(--panel-text-strong);
      transition: color 0.35s ease;
    }
    .row{ margin: 10px 0; }
    .label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin-bottom:6px;
      color: var(--panel-text);
      transition: color 0.35s ease;
    }
    .label .v{
      color: var(--panel-text-strong);
      font-variant-numeric: tabular-nums;
      transition: color 0.35s ease;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .hint{
      margin-top:10px;
      color: var(--panel-text-mute);
      font-size:12px;
      transition: color 0.35s ease;
    }
    .spawn-btn{
      width:100%;
      padding:7px 0;
      margin-top:10px;
      border:1px solid var(--panel-border);
      border-radius:6px;
      background: rgba(127,127,127,0.15);
      color: var(--panel-text-strong);
      font:500 12px/1 system-ui, -apple-system, sans-serif;
      cursor:pointer;
      transition: background 0.15s, color 0.15s;
    }
    .spawn-btn:hover{ background: rgba(127,127,127,0.30); }
    .remove-btn{
      width:100%;
      padding:7px 0;
      margin-top:5px;
      border:1px solid rgba(200,60,60,0.3);
      border-radius:6px;
      background: rgba(200,60,60,0.10);
      color: var(--panel-text-strong);
      font:500 12px/1 system-ui, -apple-system, sans-serif;
      cursor:pointer;
      transition: background 0.15s;
    }
    .remove-btn:hover{ background: rgba(200,60,60,0.25); }

    .dance-section{
      border-top:1px solid var(--panel-border);
      padding-top:10px;
      margin-top:12px;
    }
    .dance-row{
      display:flex;
      gap:6px;
      margin-top:8px;
    }
    .dance-select{
      flex:1;
      padding:6px 8px;
      border:1px solid var(--panel-border);
      border-radius:6px;
      background: rgba(127,127,127,0.15);
      color: var(--panel-text-strong);
      font:500 11px/1 system-ui, -apple-system, sans-serif;
      cursor:pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23999' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      padding-right: 24px;
    }
    .dance-btn{
      padding:6px 16px;
      border:1px solid rgba(80,180,255,0.4);
      border-radius:6px;
      background: rgba(80,180,255,0.12);
      color: var(--panel-text-strong);
      font:600 11px/1 system-ui, -apple-system, sans-serif;
      cursor:pointer;
      transition: background 0.15s;
      white-space: nowrap;
    }
    .dance-btn:hover{ background: rgba(80,180,255,0.25); }
    .dance-btn.active{
      background: rgba(80,180,255,0.35);
      border-color: rgba(80,180,255,0.7);
    }
    .dance-label{
      font-size:12px;
      font-weight:600;
      color: var(--panel-text-strong);
      letter-spacing:0.2px;
    }

    /* Swarmalator metrics panel */
    .metrics{
      position:fixed;
      right:16px; top:50px;
      z-index:3;
      width:220px;
      padding:12px 14px;
      border-radius:10px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      backdrop-filter: blur(14px) saturate(1.2);
      -webkit-backdrop-filter: blur(14px) saturate(1.2);
      color: var(--panel-text);
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      user-select:none;
      transition: background 0.35s ease, border-color 0.35s ease, color 0.35s ease;
    }
    .metrics h4{
      margin:0 0 8px; font-size:11px; font-weight:600;
      letter-spacing:0.5px; text-transform:uppercase;
      color: var(--panel-text-mute);
    }
    .m-row{
      display:flex; justify-content:space-between; align-items:center;
      padding:3px 0;
    }
    .m-label{ color: var(--panel-text); font-size:12px; }
    .m-label i{ font-style:italic; font-family: 'Times New Roman', serif; font-size:13px; }
    .m-val{
      font-variant-numeric:tabular-nums;
      color: var(--panel-text-strong);
      font-weight:500; font-size:12px;
      min-width:50px; text-align:right;
    }
    .m-sep{ border-top:1px solid var(--panel-border); margin:6px 0; }
    .m-bar-track{
      flex:1; height:4px; margin:0 8px;
      background:rgba(127,127,127,0.15);
      border-radius:2px; overflow:hidden;
    }
    .m-bar-fill{
      height:100%; border-radius:2px;
      background: rgba(var(--mag-on), 0.7);
      transition: width 0.1s;
    }
    #mSpeedBar{ opacity: 0.6; }
    .metrics input[type="range"]{
      width:100%; accent-color: var(--accent);
      margin:2px 0 0;
    }
    .m-slider{ margin-bottom:4px; }

    .game-link{
      position:fixed;
      bottom:20px; right:16px;
      z-index:4;
      padding:10px 20px;
      border-radius:8px;
      background: rgba(80,180,255,0.15);
      border:1px solid rgba(80,180,255,0.4);
      color: var(--panel-text-strong);
      font:600 13px/1 system-ui, -apple-system, sans-serif;
      text-decoration:none;
      backdrop-filter: blur(10px);
      transition: background 0.15s;
    }
    .game-link:hover{ background: rgba(80,180,255,0.30); }
  </style>
</head>
<body>

  <!-- Theme toggle -->
  <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
    <span class="toggle-icon" id="toggle-label">üåô</span>
    <div class="toggle-track"><div class="toggle-knob"></div></div>
  </button>

  <!-- Game link -->
  <a href="game.html" class="game-link">Swarm Maze Game</a>

  <div class="panel">
    <div style="text-align:center; margin-bottom:10px; padding-bottom:10px; border-bottom:1px solid var(--panel-border);">
      <div style="font-size:15px; font-weight:600; letter-spacing:0.3px; color:var(--panel-text-strong);">Virtual Swarmalator</div>
      <div style="font-size:11px; color:var(--panel-text-mute); margin-top:2px;">DH Han, SAM Lab</div>
    </div>

    <h3>Controls</h3>

    <div class="row">
      <div class="label">
        <span>number of agents</span>
        <span class="v" id="vCount"></span>
      </div>
      <input id="sCount" type="range" min="50" max="3000" step="50" value="400">
    </div>

    <div class="row">
      <div class="label">
        <span>agent diameter (mm)</span>
        <span class="v" id="vR"></span>
      </div>
      <input id="sR" type="range" min="1" max="8" step="1" value="3">
    </div>

    <div class="row">
      <div class="label">
        <span>mouse force</span>
        <span class="v" id="vMouse"></span>
      </div>
      <input id="sMouse" type="range" min="0" max="2.0" step="0.01" value="0.25">
    </div>

    <div class="row">
      <div class="label">
        <span>repulsion coefficient</span>
        <span class="v" id="vSep"></span>
      </div>
      <input id="sSep" type="range" min="0" max="3.0" step="0.01" value="0.15">
    </div>

    <div style="border-top:1px solid var(--panel-border); padding-top:10px; margin-top:12px;">
      <h3>Objects</h3>
    </div>

    <div class="row">
      <div class="label"><span>object mass</span><span class="v" id="vMass"></span></div>
      <input id="sMass" type="range" min="5" max="200" step="5" value="50">
    </div>

    <div class="row">
      <div class="label"><span>object size</span><span class="v" id="vObjSize"></span></div>
      <input id="sObjSize" type="range" min="30" max="150" step="5" value="60">
    </div>

    <button class="spawn-btn" id="btnSpawn">Spawn Object</button>
    <button class="remove-btn" id="btnRemove">Remove All Objects</button>

    <div class="dance-section">
      <h3>Dance</h3>
      <div class="row">
        <div class="label"><span>field strength</span><span class="v" id="vDanceStr"></span></div>
        <input id="sDanceStr" type="range" min="0.1" max="2.0" step="0.05" value="0.8">
      </div>
      <div class="row">
        <div class="label"><span>tempo</span><span class="v" id="vDanceTempo"></span></div>
        <input id="sDanceTempo" type="range" min="0.2" max="3.0" step="0.1" value="1.0">
      </div>
      <div class="dance-row">
        <select class="dance-select" id="danceMode">
          <option value="vortex">Vortex</option>
          <option value="wave">Wave</option>
          <option value="pulse">Pulse</option>
          <option value="split">Split &amp; Merge</option>
          <option value="figure8">Figure-8</option>
        </select>
        <button class="dance-btn" id="btnDance">Dance</button>
      </div>
    </div>

  </div>

  <div class="metrics" id="metricsPanel">
    <h4>Swarmalator Coefficients</h4>
    <div class="m-slider">
      <div class="m-row"><span class="m-label"><i>J</i> attraction</span><span class="m-val" id="mJ">0.014</span></div>
      <input id="sAtt" type="range" min="0" max="0.1" step="0.001" value="0.014">
    </div>
    <div class="m-slider">
      <div class="m-row"><span class="m-label"><i>K</i> phase coupling</span><span class="m-val" id="mK">0.0008</span></div>
      <input id="sPhase" type="range" min="0" max="0.01" step="0.0001" value="0.0008">
    </div>
    <div class="m-slider">
      <div class="m-row"><span class="m-label"><i>œÉ</i> repulsion</span><span class="m-val" id="mSigma">0.15</span></div>
      <input id="sSigma" type="range" min="0" max="3.0" step="0.01" value="0.15">
    </div>
    <div class="m-slider">
      <div class="m-row"><span class="m-label"><i>Œ≥</i> damping</span><span class="m-val" id="mGamma">0.96</span></div>
      <input id="sDamp" type="range" min="0.80" max="1.00" step="0.005" value="0.96">
    </div>
    <div class="m-slider">
      <div class="m-row"><span class="m-label"><i>F<sub>œÅ</sub></i> density force</span><span class="m-val" id="mDensF">0.00</span></div>
      <input id="sDensF" type="range" min="-1.0" max="1.0" step="0.01" value="0.0">
    </div>
    <div class="m-sep"></div>
    <h4>Order Parameters</h4>
    <div class="m-row">
      <span class="m-label"><i>Œ®</i> phase sync</span>
      <div class="m-bar-track"><div class="m-bar-fill" id="mPsiBar" style="width:0%"></div></div>
      <span class="m-val" id="mPsi">0.00</span>
    </div>
    <div class="m-row">
      <span class="m-label"><i>vÃÑ</i> avg speed</span>
      <div class="m-bar-track"><div class="m-bar-fill" id="mSpeedBar" style="width:0%"></div></div>
      <span class="m-val" id="mSpeed">0.00</span>
    </div>
    <div class="m-row"><span class="m-label">Groups</span><span class="m-val" id="mGroups">0</span></div>
    <div class="m-row"><span class="m-label"><i>N</i> agents</span><span class="m-val" id="mN">0</span></div>
  </div>

  <canvas id="particle-canvas"></canvas>

  <script>
    /* ===== Theme persistence ===== */
    const html  = document.documentElement;
    const label = document.getElementById('toggle-label');
    const saved = localStorage.getItem('theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const initial = saved || (prefersDark ? 'dark' : 'light');
    html.setAttribute('data-theme', initial);
    label.textContent = initial === 'dark' ? 'üåô' : '‚òÄÔ∏è';

    function toggleTheme(){
      const next = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', next);
      label.textContent = next === 'dark' ? 'üåô' : '‚òÄÔ∏è';
      localStorage.setItem('theme', next);
    }

    /* ===== Canvas + sim ===== */
    const canvas = document.getElementById('particle-canvas');
    const ctx    = canvas.getContext('2d');

    // UI elements
    const sCount = document.getElementById('sCount');
    const sR     = document.getElementById('sR');
    const sMouse = document.getElementById('sMouse');
    const sSep   = document.getElementById('sSep');

    const vCount = document.getElementById('vCount');
    const vR     = document.getElementById('vR');
    const vMouse = document.getElementById('vMouse');
    const vSep   = document.getElementById('vSep');

    // State
    let W, H, mouseX = -9999, mouseY = -9999;
    let particles = [];

    // --- Electromagnet grid params ---
    const MAG_SX    = 88;
    const MAG_SY    = 68;
    const MAG_R     = 20;
    const DETECT_R  = 62;
    const DETECT_R2 = DETECT_R * DETECT_R;
    const DENSITY_MAX = 14;
    const DENSITY_THRESHOLD = 5;
    const GROUP_THRESHOLD = 18;
    const GROUP_MERGE_DIST = MAG_SX * 1.6;
    let magnets = [];

    // --- Object params ---
    const sMass    = document.getElementById('sMass');
    const sObjSize = document.getElementById('sObjSize');
    const vMass    = document.getElementById('vMass');
    const vObjSize = document.getElementById('vObjSize');
    let OBJ_MASS = parseInt(sMass.value, 10);
    let OBJ_SIZE = parseInt(sObjSize.value, 10);
    const OBJ_DAMP = 0.94;
    const OBJ_ANG_DAMP = 0.92;
    const OBJ_FRICTION = 0.3;

    let objects = [];  // rigid body objects

    function createObject(x, y) {
      const w = OBJ_SIZE, h = OBJ_SIZE * 0.65;
      const mass = OBJ_MASS;
      // moment of inertia for rectangle: (1/12) * m * (w^2 + h^2)
      const inertia = (mass / 12) * (w*w + h*h);
      return { x, y, w, h, angle: 0, vx: 0, vy: 0, angVel: 0, mass, inertia };
    }

    document.getElementById('btnSpawn').addEventListener('click', () => {
      // spawn at center with slight random offset
      objects.push(createObject(
        W/2 + (Math.random()-0.5)*100,
        H/2 + (Math.random()-0.5)*100
      ));
    });
    document.getElementById('btnRemove').addEventListener('click', () => { objects = []; });

    sMass.addEventListener('input', () => { OBJ_MASS = parseInt(sMass.value, 10); updateLabels(); });
    sObjSize.addEventListener('input', () => { OBJ_SIZE = parseInt(sObjSize.value, 10); updateLabels(); });

    // --- Dance params ---
    const btnDance    = document.getElementById('btnDance');
    const danceSelect = document.getElementById('danceMode');
    const sDanceStr   = document.getElementById('sDanceStr');
    const sDanceTempo = document.getElementById('sDanceTempo');
    const vDanceStr   = document.getElementById('vDanceStr');
    const vDanceTempo = document.getElementById('vDanceTempo');

    let danceActive = false;
    let danceTime   = 0;
    let DANCE_STRENGTH = parseFloat(sDanceStr.value);
    let DANCE_TEMPO    = parseFloat(sDanceTempo.value);
    const DANCE_MAG_RANGE = 120; // how far a dance-activated magnet attracts

    sDanceStr.addEventListener('input', () => { DANCE_STRENGTH = parseFloat(sDanceStr.value); updateLabels(); });
    sDanceTempo.addEventListener('input', () => { DANCE_TEMPO = parseFloat(sDanceTempo.value); updateLabels(); });

    btnDance.addEventListener('click', () => {
      danceActive = !danceActive;
      btnDance.classList.toggle('active', danceActive);
      btnDance.textContent = danceActive ? 'Stop' : 'Dance';
      if (danceActive) danceTime = 0;
    });

    // Dance pattern functions: return activation 0-1 for a magnet at (mx, my) given time t
    const dancePatterns = {
      vortex(mx, my, t) {
        // Rotating attractor point orbiting screen center
        const cx = W/2, cy = H/2;
        const orbitR = Math.min(W, H) * 0.25;
        const ax = cx + Math.cos(t) * orbitR;
        const ay = cy + Math.sin(t) * orbitR;
        const dx = mx - ax, dy = my - ay;
        const d = Math.sqrt(dx*dx + dy*dy);
        return Math.max(0, 1 - d / (orbitR * 0.6));
      },

      wave(mx, my, t) {
        // Traveling sine wave from left to right
        const waveX = (t * W * 0.15) % (W * 1.4) - W * 0.2;
        const band = W * 0.18;
        const dist = Math.abs(mx - waveX);
        if (dist > band) return 0;
        // Vertical sine modulation
        const sineY = H/2 + Math.sin(mx * 0.015 + t * 2) * H * 0.25;
        const dy = Math.abs(my - sineY);
        const yBand = H * 0.15;
        if (dy > yBand) return 0;
        return (1 - dist/band) * (1 - dy/yBand);
      },

      pulse(mx, my, t) {
        // Expanding and contracting ring from center
        const cx = W/2, cy = H/2;
        const maxR = Math.min(W, H) * 0.38;
        const ringR = ((Math.sin(t) + 1) / 2) * maxR;
        const dx = mx - cx, dy = my - cy;
        const d = Math.sqrt(dx*dx + dy*dy);
        const ringWidth = 60;
        const dist = Math.abs(d - ringR);
        return dist < ringWidth ? (1 - dist/ringWidth) : 0;
      },

      split(mx, my, t) {
        // Two attractors that orbit: split apart then merge
        const cx = W/2, cy = H/2;
        const sep = Math.sin(t * 0.7) * Math.min(W, H) * 0.3;
        const a1x = cx - sep, a1y = cy;
        const a2x = cx + sep, a2y = cy;
        const range = 100;
        const d1 = Math.sqrt((mx-a1x)**2 + (my-a1y)**2);
        const d2 = Math.sqrt((mx-a2x)**2 + (my-a2y)**2);
        return Math.max(
          d1 < range ? 1 - d1/range : 0,
          d2 < range ? 1 - d2/range : 0
        );
      },

      figure8(mx, my, t) {
        // Lemniscate (figure-8) path
        const cx = W/2, cy = H/2;
        const a = Math.min(W, H) * 0.28;
        const ct = Math.cos(t), st = Math.sin(t);
        const denom = 1 + st * st;
        const ax = cx + (a * ct) / denom;
        const ay = cy + (a * ct * st) / denom;
        const dx = mx - ax, dy = my - ay;
        const d = Math.sqrt(dx*dx + dy*dy);
        const range = 90;
        return d < range ? 1 - d/range : 0;
      }
    };

    // --- Physics params ---
    const MOUSE_RANGE = 200;
    let MOUSE_FORCE = parseFloat(sMouse.value);

    let R = parseInt(sR.value, 10);          // particle radius (px)
    let COUNT = parseInt(sCount.value, 10);  // number of agents

    let MIN_GAP  = R * 12;
    let MIN_DIST = R * 2 + MIN_GAP;

    const ATT_DIST = 50;
    let SEP_DIST = MIN_DIST;
    let SEP_F = parseFloat(sSep.value);

    // Swarmalator coefficients (adjustable via right panel)
    const sAtt    = document.getElementById('sAtt');
    const sPhase  = document.getElementById('sPhase');
    const sSigma  = document.getElementById('sSigma');
    const sDamp   = document.getElementById('sDamp');
    const sDensF  = document.getElementById('sDensF');

    let ATT_F = parseFloat(sAtt.value);
    let PHASE_K = parseFloat(sPhase.value);
    let DAMP = parseFloat(sDamp.value);
    let DENS_FORCE = parseFloat(sDensF.value);
    const DENS_RANGE = 80; // how far a density-activated magnet affects particles
    const MAX_SPD = 4;

    window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
    window.addEventListener('mouseleave', () => { mouseX = -9999; mouseY = -9999; });

    function buildMagnets() {
      magnets = [];
      const cols = Math.ceil(W / MAG_SX) + 2;
      const rows = Math.ceil(H / MAG_SY) + 2;
      for (let row = -1; row <= rows; row++) {
        const offset = (((row % 2) + 2) % 2 === 1) ? MAG_SX / 2 : 0;
        for (let col = -1; col <= cols; col++) {
          magnets.push({ x: col * MAG_SX + offset, y: row * MAG_SY, brightness: 0, _c: 0 });
        }
      }
    }

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);

      canvas.width  = Math.floor(W * dpr);
      canvas.height = Math.floor(H * dpr);
      canvas.style.width  = W + "px";
      canvas.style.height = H + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      buildMagnets();
    }
    window.addEventListener('resize', resize);
    resize();

    function reseedParticles() {
      particles = [];
      for (let i = 0; i < COUNT; i++) {
        particles.push({
          x: Math.random() * W, y: Math.random() * H,
          vx: (Math.random()-0.5)*1.2, vy: (Math.random()-0.5)*1.2,
          phase: Math.random() * Math.PI * 2,
          r: R
        });
      }
    }
    reseedParticles();

    // ---- UI wiring ----
    function updateLabels() {
      vCount.textContent = String(COUNT);
      vR.textContent     = String(R);
      vMouse.textContent = MOUSE_FORCE.toFixed(2);
      vSep.textContent   = SEP_F.toFixed(2);
      vMass.textContent  = String(OBJ_MASS);
      vObjSize.textContent = String(OBJ_SIZE);
      vDanceStr.textContent = DANCE_STRENGTH.toFixed(2);
      vDanceTempo.textContent = DANCE_TEMPO.toFixed(1);
    }
    updateLabels();

    sCount.addEventListener('input', () => {
      COUNT = parseInt(sCount.value, 10);
      reseedParticles();
      updateLabels();
    });

    sR.addEventListener('input', () => {
      R = parseInt(sR.value, 10);
      MIN_GAP  = R * 12;
      MIN_DIST = R * 2 + MIN_GAP;
      SEP_DIST = MIN_DIST;
      reseedParticles();
      updateLabels();
    });

    sMouse.addEventListener('input', () => {
      MOUSE_FORCE = parseFloat(sMouse.value);
      updateLabels();
    });

    sSep.addEventListener('input', () => {
      SEP_F = parseFloat(sSep.value);
      sSigma.value = sSep.value; // sync right panel
      updateLabels();
    });

    // Right-panel swarmalator coefficient sliders
    sAtt.addEventListener('input', () => { ATT_F = parseFloat(sAtt.value); });
    sPhase.addEventListener('input', () => { PHASE_K = parseFloat(sPhase.value); });
    sDamp.addEventListener('input', () => { DAMP = parseFloat(sDamp.value); });
    sSigma.addEventListener('input', () => {
      SEP_F = parseFloat(sSigma.value);
      sSep.value = sSigma.value; // sync left panel
      updateLabels();
    });
    sDensF.addEventListener('input', () => { DENS_FORCE = parseFloat(sDensF.value); });

    // ===== Theme-aware colors for canvas (cached) =====
    let colorCache = null, lastTheme = '';
    function getColors(){
      const theme = html.getAttribute('data-theme');
      if (theme === lastTheme && colorCache) return colorCache;
      lastTheme = theme;

      const style = getComputedStyle(html);
      colorCache = {
        particle: style.getPropertyValue('--particle-color').trim(),
        magOff:   style.getPropertyValue('--mag-off').trim(),
        magOn:    style.getPropertyValue('--mag-on').trim(),
      };
      return colorCache;
    }

    function drawFrame() {
      ctx.clearRect(0, 0, W, H);
      const C = getColors();

      // 1) density from particles -> magnets
      for (let m = 0; m < magnets.length; m++) magnets[m]._c = 0;
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        for (let m = 0; m < magnets.length; m++) {
          const mg = magnets[m];
          const dx = p.x - mg.x, dy = p.y - mg.y;
          if (dx*dx + dy*dy < DETECT_R2) mg._c++;
        }
      }

      // 2) dance: compute magnet activation + advance time
      if (danceActive) danceTime += 0.016 * DANCE_TEMPO;
      const patternFn = danceActive ? dancePatterns[danceSelect.value] : null;

      // 2b) draw electromagnets (behind particles)
      for (let m = 0; m < magnets.length; m++) {
        const mg = magnets[m];
        // Dance activation (0-1)
        mg._dance = patternFn ? patternFn(mg.x, mg.y, danceTime) : 0;

        const densityRaw = Math.max(0, Math.min((mg._c - DENSITY_THRESHOLD) / (DENSITY_MAX - DENSITY_THRESHOLD), 1));
        const raw = Math.max(densityRaw, mg._dance);
        const target = Math.pow(raw, 0.55);
        mg.brightness += (target - mg.brightness) * 0.12;
        const b = mg.brightness;

        ctx.beginPath();
        ctx.arc(mg.x, mg.y, MAG_R, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(${C.magOff},${0.10 + b * 0.08})`;
        ctx.lineWidth = 0.8;
        ctx.stroke();

        if (b > 0.015) {
          const grad = ctx.createRadialGradient(mg.x, mg.y, 0, mg.x, mg.y, MAG_R * (1 + b * 0.6));
          grad.addColorStop(0,    `rgba(${C.magOn},${b * 0.92})`);
          grad.addColorStop(0.45, `rgba(${C.magOn},${b * 0.55})`);
          grad.addColorStop(0.8,  `rgba(${C.magOn},${b * 0.18})`);
          grad.addColorStop(1,    `rgba(${C.magOn},0)`);

          ctx.beginPath();
          ctx.arc(mg.x, mg.y, MAG_R * (1 + b * 0.6), 0, Math.PI * 2);
          ctx.fillStyle = grad;
          ctx.fill();
        }
      }

      // 3) particle physics + draw
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];

        // Mouse attraction
        const mdx = mouseX - p.x, mdy = mouseY - p.y;
        const md  = Math.sqrt(mdx*mdx + mdy*mdy);
        if (md < MOUSE_RANGE && md > 1) {
          const f = MOUSE_FORCE * (1 - md / MOUSE_RANGE);
          p.vx += (mdx/md) * f;
          p.vy += (mdy/md) * f;
        }

        // Dance: electromagnetic field forces from activated magnets
        if (danceActive) {
          for (let m = 0; m < magnets.length; m++) {
            const mg = magnets[m];
            if (mg._dance < 0.05) continue;
            const dmx = mg.x - p.x, dmy = mg.y - p.y;
            const dd = Math.sqrt(dmx*dmx + dmy*dmy);
            if (dd < 1 || dd > DANCE_MAG_RANGE) continue;
            const falloff = 1 - dd / DANCE_MAG_RANGE;
            const ff = mg._dance * DANCE_STRENGTH * falloff * 0.6;
            p.vx += (dmx/dd) * ff;
            p.vy += (dmy/dd) * ff;
          }
        }

        // Density-based electromagnetic force: magnets with high particle density push/pull
        if (DENS_FORCE !== 0) {
          for (let m = 0; m < magnets.length; m++) {
            const mg = magnets[m];
            if (mg._c < DENSITY_THRESHOLD) continue;
            const dmx = mg.x - p.x, dmy = mg.y - p.y;
            const dd = Math.sqrt(dmx*dmx + dmy*dmy);
            if (dd < 1 || dd > DENS_RANGE) continue;
            const density = Math.min((mg._c - DENSITY_THRESHOLD) / (DENSITY_MAX - DENSITY_THRESHOLD), 1);
            const falloff = 1 - dd / DENS_RANGE;
            const ff = DENS_FORCE * density * falloff * 0.5;
            p.vx += (dmx/dd) * ff;
            p.vy += (dmy/dd) * ff;
          }
        }

        // Swarmalator coupling
        for (let j = i + 1; j < particles.length; j++) {
          const q = particles[j];
          const dx = q.x - p.x, dy = q.y - p.y;
          const d  = Math.sqrt(dx*dx + dy*dy);
          if (d < 1 || d > ATT_DIST) continue;

          const nx = dx / d, ny = dy / d;
          if (d < SEP_DIST) {
            const f = SEP_F * (1 - d / SEP_DIST);
            p.vx -= nx * f; p.vy -= ny * f;
            q.vx += nx * f; q.vy += ny * f;
          } else {
            const sync = (1 + Math.cos(q.phase - p.phase)) * 0.5;
            const f = ATT_F * sync;
            p.vx += nx * f; p.vy += ny * f;
            q.vx -= nx * f; q.vy -= ny * f;

            const dp = PHASE_K * Math.sin(q.phase - p.phase);
            p.phase += dp; q.phase -= dp;
          }
        }

        p.vx *= DAMP; p.vy *= DAMP;

        const spd = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
        if (spd > MAX_SPD) {
          p.vx = (p.vx / spd) * MAX_SPD;
          p.vy = (p.vy / spd) * MAX_SPD;
        }

        p.x += p.vx;
        p.y += p.vy;

        // Closed boundary ‚Äî reflect off walls
        if (p.x < p.r)     { p.x = p.r;     p.vx *= -0.5; }
        if (p.x > W - p.r) { p.x = W - p.r; p.vx *= -0.5; }
        if (p.y < p.r)     { p.y = p.r;     p.vy *= -0.5; }
        if (p.y > H - p.r) { p.y = H - p.r; p.vy *= -0.5; }

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${C.particle},0.65)`;
        ctx.fill();
      }

      // 4) Rigid body objects ‚Äî collision with particles + physics + draw
      for (let oi = 0; oi < objects.length; oi++) {
        const obj = objects[oi];
        const cosA = Math.cos(obj.angle), sinA = Math.sin(obj.angle);
        const hw = obj.w / 2, hh = obj.h / 2;

        // Particle ‚Üî Object collision
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          // Transform particle into object local space
          const lx = cosA * (p.x - obj.x) + sinA * (p.y - obj.y);
          const ly = -sinA * (p.x - obj.x) + cosA * (p.y - obj.y);

          // Closest point on box in local space
          const clx = Math.max(-hw, Math.min(hw, lx));
          const cly = Math.max(-hh, Math.min(hh, ly));

          const dlx = lx - clx, dly = ly - cly;
          const dist2 = dlx*dlx + dly*dly;
          const rr = p.r + 1; // small skin

          if (dist2 < rr * rr && dist2 > 0.01) {
            const dist = Math.sqrt(dist2);
            // Normal in local space
            const nlx = dlx / dist, nly = dly / dist;
            // Transform normal back to world space
            const nx = cosA * nlx - sinA * nly;
            const ny = sinA * nlx + cosA * nly;

            // Contact point in world space
            const cpx = cosA * clx - sinA * cly + obj.x;
            const cpy = sinA * clx + cosA * cly + obj.y;

            // Relative velocity at contact
            const rx = cpx - obj.x, ry = cpy - obj.y;
            const objVxAtContact = obj.vx - obj.angVel * ry;
            const objVyAtContact = obj.vy + obj.angVel * rx;
            const relVx = p.vx - objVxAtContact;
            const relVy = p.vy - objVyAtContact;
            const relVn = relVx * nx + relVy * ny;

            if (relVn < 0) { // approaching
              const rCrossN = rx * ny - ry * nx;
              const invMassSum = (1 / 0.5) + (1 / obj.mass) + (rCrossN * rCrossN) / obj.inertia;
              const restitution = 0.3;
              const j = -(1 + restitution) * relVn / invMassSum;

              // Apply impulse to particle
              p.vx += j * nx * 2;  // particle is light
              p.vy += j * ny * 2;

              // Apply impulse to object
              obj.vx -= (j * nx) / obj.mass;
              obj.vy -= (j * ny) / obj.mass;
              obj.angVel -= (j * rCrossN) / obj.inertia;
            }

            // Separate overlap
            const overlap = rr - dist;
            p.x += nx * overlap * 0.7;
            p.y += ny * overlap * 0.7;
            obj.x -= nx * overlap * 0.3;
            obj.y -= ny * overlap * 0.3;
          }
        }

        // Object-Object collision (simple AABB push apart)
        for (let oj = oi + 1; oj < objects.length; oj++) {
          const ob = objects[oj];
          const dx = ob.x - obj.x, dy = ob.y - obj.y;
          const minDist = (obj.w + ob.w) / 2;
          const d = Math.sqrt(dx*dx + dy*dy);
          if (d < minDist && d > 0.1) {
            const nx = dx/d, ny = dy/d;
            const overlap = minDist - d;
            obj.x -= nx * overlap * 0.5;
            obj.y -= ny * overlap * 0.5;
            ob.x  += nx * overlap * 0.5;
            ob.y  += ny * overlap * 0.5;
            // exchange some velocity
            const relV = (obj.vx - ob.vx)*nx + (obj.vy - ob.vy)*ny;
            if (relV > 0) {
              obj.vx -= relV * nx * 0.5;
              obj.vy -= relV * ny * 0.5;
              ob.vx  += relV * nx * 0.5;
              ob.vy  += relV * ny * 0.5;
            }
          }
        }

        // Integrate object
        obj.vx *= OBJ_DAMP;
        obj.vy *= OBJ_DAMP;
        obj.angVel *= OBJ_ANG_DAMP;
        // Friction (ground drag proportional to mass)
        const spd = Math.sqrt(obj.vx*obj.vx + obj.vy*obj.vy);
        if (spd > 0.01) {
          const fric = Math.min(OBJ_FRICTION / obj.mass, spd);
          obj.vx -= (obj.vx/spd) * fric;
          obj.vy -= (obj.vy/spd) * fric;
        }
        obj.x += obj.vx;
        obj.y += obj.vy;
        obj.angle += obj.angVel;

        // Keep in bounds
        obj.x = Math.max(hw, Math.min(W - hw, obj.x));
        obj.y = Math.max(hh, Math.min(H - hh, obj.y));

        // Draw object
        ctx.save();
        ctx.translate(obj.x, obj.y);
        ctx.rotate(obj.angle);
        ctx.beginPath();
        ctx.rect(-hw, -hh, obj.w, obj.h);
        const isDark = html.getAttribute('data-theme') === 'dark';
        ctx.fillStyle = isDark ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)';
        ctx.fill();
        ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.4)' : 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Mass label
        ctx.fillStyle = isDark ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.45)';
        ctx.font = '500 10px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`m=${obj.mass}`, 0, 0);
        ctx.restore();
      }

      // 5) Group detection & swarm outline
      const hotMagnets = [];
      for (let m = 0; m < magnets.length; m++) {
        if (magnets[m]._c >= GROUP_THRESHOLD) hotMagnets.push(magnets[m]);
      }

      const visited = new Set();
      const clusters = [];
      for (let i = 0; i < hotMagnets.length; i++) {
        if (visited.has(i)) continue;
        const cluster = [hotMagnets[i]];
        visited.add(i);
        const stack = [i];
        while (stack.length) {
          const ci = stack.pop();
          for (let j = 0; j < hotMagnets.length; j++) {
            if (visited.has(j)) continue;
            const dx = hotMagnets[ci].x - hotMagnets[j].x;
            const dy = hotMagnets[ci].y - hotMagnets[j].y;
            if (dx*dx + dy*dy < GROUP_MERGE_DIST * GROUP_MERGE_DIST) {
              visited.add(j);
              cluster.push(hotMagnets[j]);
              stack.push(j);
            }
          }
        }
        if (cluster.length >= 2) clusters.push(cluster);
      }

      for (const cluster of clusters) {
        const groupPts = [];
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          for (const mg of cluster) {
            const dx = p.x - mg.x, dy = p.y - mg.y;
            if (dx*dx + dy*dy < DETECT_R2) { groupPts.push(p); break; }
          }
        }
        if (groupPts.length < 3) continue;

        // Convex hull (Andrew's monotone chain)
        const pts = groupPts.map(p => [p.x, p.y]).sort((a,b) => a[0]-b[0] || a[1]-b[1]);
        const cross = (O,A,B) => (A[0]-O[0])*(B[1]-O[1]) - (A[1]-O[1])*(B[0]-O[0]);
        const lower = [];
        for (const p of pts) { while (lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop(); lower.push(p); }
        const upper = [];
        for (let i = pts.length-1; i >= 0; i--) { const p = pts[i]; while (upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop(); upper.push(p); }
        lower.pop(); upper.pop();
        const hull = lower.concat(upper);
        if (hull.length < 3) continue;

        // Expand hull outward
        const PAD = 18;
        let cx = 0, cy = 0;
        for (const h of hull) { cx += h[0]; cy += h[1]; }
        cx /= hull.length; cy /= hull.length;
        const expanded = hull.map(h => {
          const dx = h[0] - cx, dy = h[1] - cy;
          const d = Math.sqrt(dx*dx + dy*dy) || 1;
          return [h[0] + dx/d * PAD, h[1] + dy/d * PAD];
        });

        // Draw smooth dashed outline
        ctx.beginPath();
        ctx.moveTo(expanded[0][0], expanded[0][1]);
        for (let i = 0; i < expanded.length; i++) {
          const curr = expanded[i];
          const next = expanded[(i+1) % expanded.length];
          const mx = (curr[0] + next[0]) / 2, my = (curr[1] + next[1]) / 2;
          ctx.quadraticCurveTo(curr[0], curr[1], mx, my);
        }
        ctx.closePath();
        ctx.strokeStyle = `rgba(${C.magOn},0.55)`;
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6, 4]);
        ctx.stroke();
        ctx.setLineDash([]);

        // "Swarm" label at top of hull
        ctx.font = '500 11px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = `rgba(${C.magOn},0.7)`;
        let topY = Infinity, topX = 0;
        for (const h of expanded) { if (h[1] < topY) { topY = h[1]; topX = h[0]; } }
        ctx.textAlign = 'center';
        ctx.fillText('Swarm', topX, topY - 8);
      }

      // ===== Compute & display swarmalator metrics =====
      // Phase order parameter: Œ® = |1/N Œ£ e^{iŒ∏_k}|
      let sumCos = 0, sumSin = 0, sumSpd = 0;
      const N = particles.length;
      for (let i = 0; i < N; i++) {
        const p = particles[i];
        sumCos += Math.cos(p.phase);
        sumSin += Math.sin(p.phase);
        sumSpd += Math.sqrt(p.vx * p.vx + p.vy * p.vy);
      }
      const psi = Math.sqrt(sumCos * sumCos + sumSin * sumSin) / N;
      const avgSpd = sumSpd / N;

      document.getElementById('mJ').textContent = ATT_F.toFixed(4);
      document.getElementById('mK').textContent = PHASE_K.toFixed(4);
      document.getElementById('mSigma').textContent = SEP_F.toFixed(3);
      document.getElementById('mGamma').textContent = DAMP.toFixed(3);
      document.getElementById('mDensF').textContent = DENS_FORCE.toFixed(2);
      document.getElementById('mPsi').textContent = psi.toFixed(3);
      document.getElementById('mPsiBar').style.width = (psi * 100) + '%';
      document.getElementById('mSpeed').textContent = avgSpd.toFixed(2);
      document.getElementById('mSpeedBar').style.width = Math.min(avgSpd / MAX_SPD * 100, 100) + '%';
      document.getElementById('mGroups').textContent = String(clusters.length);
      document.getElementById('mN').textContent = String(N);

      requestAnimationFrame(drawFrame);
    }

    drawFrame();
  </script>
</body>
</html>
